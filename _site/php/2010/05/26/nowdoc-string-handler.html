<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Nowdoc string handler | DeeEmm</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Nowdoc string handler" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Some of you may be familiar with the heredoc string handler which allows multi-line strings to be easily assigned to a variable, this great tool has many uses - such as retaining pre-formatted layout and improving the readability of code. The heredoc handler also parses variables contained within the string - much the same way that using double quotes does. Replacing any variables with their respective values This has some not so obvious drawbacks, one of which i discovered whilst trying to inject complex PHP code into a database for later evaluation via the eval() statement. (please don&#39;t ask why) The problem I found was that whilst it was easy to escape the string so that it would not break the SQL statement, The same escape characters also broke the evaluation. This might not have been an issue in any other situation, but for this particular project i did not have access to the code that carried out the evaluation so that I could strip the escape characters out before running the eval query. However, PHP 5.3 has now introduced the nowdoc syntax - this basically operates in the same manner as heredoc, but does not parse any of the content. This means that not only are variables not parsed, but neither are any characters that would normally require escaping. In essence, any string read into a variable by the nowdoc handler will not require any escaping whatsoever. heredoc format $somevar = &lt;&lt;your multiline text$hereEOF; nowdoc format $somevar = &lt;&lt;your multiline text$hereEOF; Th difference is only a small one - the nowdoc syntax has single quotes around the identifier. A great fix for an annoying issue, but one that is unfortunately not without it&#39;s caveats, the biggest one being that PHP 5.3 is still relatively new and there is no backwards equivalent." />
<meta property="og:description" content="Some of you may be familiar with the heredoc string handler which allows multi-line strings to be easily assigned to a variable, this great tool has many uses - such as retaining pre-formatted layout and improving the readability of code. The heredoc handler also parses variables contained within the string - much the same way that using double quotes does. Replacing any variables with their respective values This has some not so obvious drawbacks, one of which i discovered whilst trying to inject complex PHP code into a database for later evaluation via the eval() statement. (please don&#39;t ask why) The problem I found was that whilst it was easy to escape the string so that it would not break the SQL statement, The same escape characters also broke the evaluation. This might not have been an issue in any other situation, but for this particular project i did not have access to the code that carried out the evaluation so that I could strip the escape characters out before running the eval query. However, PHP 5.3 has now introduced the nowdoc syntax - this basically operates in the same manner as heredoc, but does not parse any of the content. This means that not only are variables not parsed, but neither are any characters that would normally require escaping. In essence, any string read into a variable by the nowdoc handler will not require any escaping whatsoever. heredoc format $somevar = &lt;&lt;your multiline text$hereEOF; nowdoc format $somevar = &lt;&lt;your multiline text$hereEOF; Th difference is only a small one - the nowdoc syntax has single quotes around the identifier. A great fix for an annoying issue, but one that is unfortunately not without it&#39;s caveats, the biggest one being that PHP 5.3 is still relatively new and there is no backwards equivalent." />
<link rel="canonical" href="http://localhost:4000/php/2010/05/26/nowdoc-string-handler.html" />
<meta property="og:url" content="http://localhost:4000/php/2010/05/26/nowdoc-string-handler.html" />
<meta property="og:site_name" content="DeeEmm" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-05-26T05:01:35+09:30" />
<script type="application/ld+json">
{"description":"Some of you may be familiar with the heredoc string handler which allows multi-line strings to be easily assigned to a variable, this great tool has many uses - such as retaining pre-formatted layout and improving the readability of code. The heredoc handler also parses variables contained within the string - much the same way that using double quotes does. Replacing any variables with their respective values This has some not so obvious drawbacks, one of which i discovered whilst trying to inject complex PHP code into a database for later evaluation via the eval() statement. (please don&#39;t ask why) The problem I found was that whilst it was easy to escape the string so that it would not break the SQL statement, The same escape characters also broke the evaluation. This might not have been an issue in any other situation, but for this particular project i did not have access to the code that carried out the evaluation so that I could strip the escape characters out before running the eval query. However, PHP 5.3 has now introduced the nowdoc syntax - this basically operates in the same manner as heredoc, but does not parse any of the content. This means that not only are variables not parsed, but neither are any characters that would normally require escaping. In essence, any string read into a variable by the nowdoc handler will not require any escaping whatsoever. heredoc format $somevar = &lt;&lt;your multiline text$hereEOF; nowdoc format $somevar = &lt;&lt;your multiline text$hereEOF; Th difference is only a small one - the nowdoc syntax has single quotes around the identifier. A great fix for an annoying issue, but one that is unfortunately not without it&#39;s caveats, the biggest one being that PHP 5.3 is still relatively new and there is no backwards equivalent.","@type":"BlogPosting","headline":"Nowdoc string handler","dateModified":"2010-05-26T05:01:35+09:30","datePublished":"2010-05-26T05:01:35+09:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/php/2010/05/26/nowdoc-string-handler.html"},"url":"http://localhost:4000/php/2010/05/26/nowdoc-string-handler.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DeeEmm" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">DeeEmm</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/archives/">Archives</a><a class="page-link" href="/blog/">Blog</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Nowdoc string handler</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2010-05-26T05:01:35+09:30" itemprop="datePublished">May 26, 2010
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Some of you may be familiar with the <strong><em>heredoc</em></strong> string handler which allows multi-line strings to be easily assigned to a variable, this great tool has many uses - such as retaining pre-formatted layout and improving the readability of code. The heredoc handler also parses variables contained within the string - much the same way that using double quotes does. Replacing any variables with their respective values</p>
<p>This has some not so obvious drawbacks, one of which i discovered whilst trying to inject complex PHP code into a database for later evaluation via the eval() statement. (please don't ask why)</p>
<p>The problem I found was that whilst it was easy to escape the string so that it would not break the SQL statement, The same escape characters also broke the evaluation. This might not have been an issue in any other situation, but for this particular project i did not have access to the code that carried out the evaluation so that I could strip the escape characters out before running the eval query.</p>
<p>However, PHP 5.3 has now introduced the nowdoc syntax - this basically operates in the same manner as heredoc, but does not parse any of the content. This means that not only are variables not parsed, but neither are any characters that would normally require escaping. In essence, any string read into a variable by the nowdoc handler will not require any escaping whatsoever.</p>
<p><strong>heredoc format</strong></p>
<pre>$somevar = &lt;&lt;your multi<br />line text<br />$here<br />EOF;</pre>
<p><strong>nowdoc format</strong></p>
<pre>$somevar = &lt;&lt;your multi<br />line text<br />$here<br />EOF;</pre>
<p>Th difference is only a small one - the nowdoc syntax has single quotes around the identifier.</p>
<p>A great fix for an annoying issue, but one that is unfortunately not without it's caveats, the biggest one being that PHP 5.3 is still relatively new and there is no backwards equivalent.</p>

  </div><a class="u-url" href="/php/2010/05/26/nowdoc-string-handler.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">DeeEmm</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">DeeEmm</li><li><a class="u-email" href="mailto:deeemmm@deeemm.com">deeemmm@deeemm.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/DeeEmm"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">DeeEmm</span></a></li><li><a href="https://www.twitter.com/DeeEmm__"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">DeeEmm__</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Waxing lyrical about life the universe and everything tech related since lunchtime 2006.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
